@page "/notebooks/{nbId}"
@using WorklogDomain
@using Algorithms.Encryption
@using WorklogWebAssembly.Client.Data
@inject HttpClient Http
@inject AppState AppState
@inject ISymmetricEncryptor enc

@if (notebook == null && !NbNotFound)
{
  <p>Loading Notebook...</p>
} else if (NbNotFound)
{
    <p>Notebook with ID <pre>@NbId</pre> not found </p>
} else
{

<table width="100%" border="1">
    <tr>
        <td colspan="2">
            @notebook.Name [@notebook.Created.ToString("yyyy-MM-dd HH:mm:ss")]
            Show <input type="text" size="3" value="@NumLastRecords" @onchange="@((ChangeEventArgs __e) => ChangedNumLastRecords(__e.Value.ToString()))" /> last records
        </td>
    </tr>
    @foreach (var r in ((notebook.Records ?? new List<Record>()).TakeLast(NumLastRecords)))
    {
        var rId = r.Id;
        if (!dOpts.ContainsKey(rId)) dOpts[rId] = userSettings.DefaultShowEncryptedOptions.Clone();
        <tr>
            <td style="width: 5%" valign="top"><span style="font-size: xx-small"><nobr>@r.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")</nobr></span></td>
            <td style="width: 95%">
                <div style="width: 100%; text-overflow: ellipsis; word-wrap: break-word;">
                    @if (!r.Metadata.Encrypted)
                    {
                        @((MarkupString)CleanupAndPrepare(r.Content))
                    }
                    else
                    {
                        <span>
                            <span style="@(dOpts[rId].showEncrypted ? "font-size: xx-small" : dOpts[rId].decrypt ? "color: darkblue" : "font-style: italic; color: brown")">
                                @((MarkupString)CleanupAndPrepare(Decrypt(dOpts[rId], r.Content)))
                            </span>
                            <br />
                            Show Encrypted:
                            <input type="checkbox" checked="@dOpts[rId].showEncrypted"
                                   @onclick="() => { dOpts[rId].showEncrypted = !dOpts[rId].showEncrypted;}" /><br />
                            Decrypt:
                            <input type="checkbox" checked="@dOpts[rId].decrypt"
                                   @onclick="() => { dOpts[rId].decrypt = !dOpts[rId].decrypt;}" /><br />
                            Key: <input type="text" @bind-value="dOpts[rId].key" />
                        </span>

                    }
                </div>
            </td>
        </tr>
    }
<tr>
    <td colspan="2">
            <textarea id="NewRecordContent" style="width: 100%"
                      @bind="NewRecordContent"
                      @bind:event="oninput"
                      @onkeydown="(KeyboardEventArgs e) => AddRecordByEnter(e)"
                      @ref="NewRecordContentElem" />
            <input type="checkbox" id="encrypt" checked="@EncryptContent" @onclick="() => EncryptContent = !EncryptContent"/> Encrypt
            Key: <input type="text" id="enckey" @bind-value="EncryptionKey"/>
            <button @onclick="AddRecord">Add</button>
    </td>
</tr>
</table>
}

@code {
    [Parameter]
    public string NbId { get; set; }
    protected Notebook notebook { get; set; }
    protected bool NbNotFound = false;
    protected int NumLastRecords { get; set; }


    protected string NewRecordContent = "";
    private ElementReference NewRecordContentElem;

    private bool EncryptContent = false;
    private string EncryptionKey;

    protected Dictionary<string, ShowEncryptedOptions> dOpts = new Dictionary<string, ShowEncryptedOptions>();


    protected UserSettings userSettings;

    protected override async Task OnInitializedAsync()
    {
        await ReloadNotebook();
        userSettings = (await AppState.Retrieve<UserSettings>("UserSettings")) ?? new UserSettings();
        NumLastRecords = userSettings.DefaultRecordsToShow;
    }


    protected string CleanupAndPrepare(string txt)
    {
        var safeStr = txt.Replace("<", "&lt;");
        var prepared = string.Join("<wbr/>", ChunksUpto(safeStr, 10));
        prepared = prepared.Replace("\r\n", "\n").Replace("\n", "<br/>");
        return prepared;
    }

    static IEnumerable<string> ChunksUpto(string str, int maxChunkSize)
    {
        for (int i = 0; i < str.Length; i += maxChunkSize)
            yield return str.Substring(i, Math.Min(maxChunkSize, str.Length - i));
    }

    protected string Decrypt(ShowEncryptedOptions dOpt, string text)
    {
        if (dOpt.showEncrypted) return text;
        if (!dOpt.decrypt || string.IsNullOrWhiteSpace(dOpt.key)) return "Encrypted Record";
        try
        {
            var decr = enc.DecryptFromB64(dOpt.key, text);
            return decr;
        } catch (WrongKeyException)
        {
            return "Cannot decrypt: wrong key";
        } catch (WrongEncryptedContentException)
        {
            return "Cannot decrypt: wrong format";
        } catch
        {
            return "Cannot decrypt: unknown reason";
        }
    }

    protected async Task ReloadNotebook()
    {
        try
        {
            notebook = await Http.GetFromJsonAsync<Notebook>($"api/notebook/{NbId}");
        }
        catch
        {
            NbNotFound = true;
        }
    }
    protected void ChangedNumLastRecords(string numS)
    {
        if (int.TryParse(numS, out int num))
        {
            NumLastRecords = num;
            //await AppState.Store(nameof(NumLastRecords), NumLastRecords);
        }
    }
    protected async Task AddRecordByEnter(KeyboardEventArgs e)
    {
        if ((e.Code == "Enter" || e.Code == "NumpadEnter") && !(e.AltKey || e.ShiftKey || e.CtrlKey))
        {
            await AddRecord();
        }
    }
    protected async Task AddRecord()
    {
        var rec = new Record();
        if (EncryptContent)
        {
            rec.Metadata.Encrypted = true;
            rec.Content = enc.EncryptAndReturnB64(EncryptionKey, NewRecordContent);
        } else
        {
            rec.Content = NewRecordContent;
        }
        await Http.PostAsJsonAsync($"api/notebook/{NbId}/record", rec);
        NewRecordContent = "";
        await ReloadNotebook();
        await NewRecordContentElem.FocusAsync();
    }
    protected async Task RemoveRecord(string recId)
    {
        await Http.DeleteAsync($"api/notebook/{NbId}/record/{recId}");
        await ReloadNotebook();
    }


}
