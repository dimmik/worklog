@page "/notebooks/{nbId}"
@using WorklogDomain
@using Algorithms.Encryption
@using WorklogWebAssembly.Client.Data
@using System.Text.Json
@inject HttpClient Http
@inject AppState AppState
@inject ISymmetricEncryptor enc
@inject IJSRuntime JsRuntime

@if (notebook == null && !NbNotFound)
{
    <p>Loading Notebook...</p>
}
else if (NbNotFound)
{
    <p>Notebook with ID <pre>@NbId</pre> not found </p>
}
else
{

    <table width="100%" border="1">
        <tr>
            <td colspan="2">
                <b>@notebook.Name</b> <span style="font-size:xx-small">[@notebook.Created.ToString("yyyy-MM-dd HH:mm:ss")]</span> 
                <span class="button small-btn" style="cursor:pointer" @onclick="ReloadNotebook">Refresh</span><br />
                <span style="font-size:x-small">
                    Show <input type="text" size="3" value="@NumLastRecords" @onchange="@((ChangeEventArgs __e) => ChangedNumLastRecords(__e.Value.ToString()))" />
                    last records out of @((notebook.Records ?? new List<Record>()).Count())
                    |
                    completed: <input type="checkbox" checked="@ShowCompleted" @onclick="() => ShowCompleted = !ShowCompleted"/>
                </span>
            </td>
        </tr>
        @foreach (var r in ((notebook.Records ?? new List<Record>()).Where(r => ShowCompleted || !r.Metadata.Completed).OrderBy(r => r.Timestamp).TakeLast(NumLastRecords)))
        {
            var rId = r.Id;

            if (!dOpts.ContainsKey(rId)) dOpts[rId] = userSettings.DefaultShowEncryptedOptions.Clone();
            if (!recs.ContainsKey(rId)) recs[rId] = r;

            <tr>
                <td style="width: 5%" valign="top" align="center">
                    <span style="font-size: xx-small">
                        <nobr>@r.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")</nobr>
                        <span id="@rId"
                              style="border: 1px solid black; background-color: @(recs[rId].Metadata.Completed ? "lightblue" : "white"); color: @(recs[rId].Metadata.Completed ? "lightblue" : "white"); cursor: pointer; font-size: small"
                              @onclick="async () => { recs[rId].Metadata.Completed = !recs[rId].Metadata.Completed; await UpdateRecord(recs[rId]); }">
                            O
                        </span>

                    </span>
                </td>
                <td style="width: 95%">
                    <div style="width: 100%; text-overflow: ellipsis; word-wrap: break-word; @(r.Metadata.Completed ? "text-decoration: line-through" : "")">
                        <!--((MarkupString)CleanupAndPrepare(JsonSerializer.Serialize(r.Metadata, new JsonSerializerOptions() { WriteIndented = true })))-->
                        @if (!r.Metadata.Encrypted)
                        {
                            @((MarkupString)CleanupAndPrepare(r.Content))
                        }
                        else
                        {
                            <span>
                                <span style="@(dOpts[rId].showEncrypted ? "font-size: xx-small; color: DarkGrey" : dOpts[rId].decrypt ? "color: darkblue" : "font-style: italic; color: brown")">
                                    @((MarkupString)CleanupAndPrepare(Decrypt(dOpts[rId], r.Content)))
                                </span>
                                <br />
                                <span style="font-size: x-small">
                                    <input type="checkbox" id="@($"se{rId}")" checked="@dOpts[rId].showEncrypted"
                                           @onclick="() => { dOpts[rId].showEncrypted = !dOpts[rId].showEncrypted;}" />
                                    <label for="@($"se{rId}")">Show Encrypted</label>


                                    <input type="checkbox" id="@($"d{rId}")" checked="@dOpts[rId].decrypt"
                                           @onclick="() => { dOpts[rId].decrypt = !dOpts[rId].decrypt;}" />
                                    <label for="@($"d{rId}")">Decrypt</label>

                                    <input type="password" id="@($"k{rId}")" @bind-value="dOpts[rId].key" />
                                </span>
                            </span>

                        }
                    </div>
                </td>
            </tr>
        }
        <tr>
            <td colspan="2">
                <textarea id="NewRecordContent" style="width: 100%"
                          @bind="NewRecordContent"
                          @bind:event="oninput"
                          @onkeydown="(KeyboardEventArgs e) => AddRecordByEnter(e)"
                          @ref="NewRecordContentElem" />
                <span style="font-size:x-small">
                    <input type="checkbox" id="encrypt" checked="@EncryptContent" @onclick="() => EncryptContent = !EncryptContent" /> Encrypt
                    Key: <input type="password" id="enckey" @bind-value="EncryptionKey" />
                </span>
                <button @onclick="AddRecord">Add</button>
            </td>
        </tr>
    </table>
}

@code {
    [Parameter]
    public string NbId { get; set; }
    protected Notebook notebook { get; set; }
    protected bool NbNotFound = false;
    protected int NumLastRecords { get; set; }
    protected bool ShowCompleted { get; set; }


    protected string NewRecordContent = "";
    private ElementReference NewRecordContentElem;

    private bool EncryptContent = false;
    private string EncryptionKey;

    protected Dictionary<string, ShowEncryptedOptions> dOpts = new Dictionary<string, ShowEncryptedOptions>();
    protected Dictionary<string, Record> recs = new Dictionary<string, Record>();


    protected UserSettings userSettings;

    protected override async Task OnInitializedAsync()
    {
        await ReloadNotebook();
        userSettings = (await AppState.Retrieve<UserSettings>("UserSettings")) ?? new UserSettings();
        NumLastRecords = userSettings.DefaultRecordsToShow;
        ShowCompleted = userSettings.ShowCompleted;
        EncryptionKey = userSettings.DefaultShowEncryptedOptions.key;
    }


    protected string CleanupAndPrepare(string txt)
    {
        var safeStr = txt.Replace("<", "&lt;");
        var prepared = string.Join("<wbr/>", ChunksUpto(safeStr, 10));
        prepared = prepared.Replace("\r\n", "\n").Replace("\n", "<br/>");
        return prepared;
    }

    static IEnumerable<string> ChunksUpto(string str, int maxChunkSize)
    {
        for (int i = 0; i < str.Length; i += maxChunkSize)
            yield return str.Substring(i, Math.Min(maxChunkSize, str.Length - i));
    }

    protected string Decrypt(ShowEncryptedOptions dOpt, string text)
    {
        if (dOpt.showEncrypted) return text;
        if (!dOpt.decrypt || string.IsNullOrWhiteSpace(dOpt.key)) return "Encrypted Record";
        try
        {
            var decr = enc.DecryptFromB64(dOpt.key, text);
            return decr;
        }
        catch (WrongKeyException)
        {
            return "Cannot decrypt: wrong key";
        }
        catch (WrongEncryptedContentException)
        {
            return "Cannot decrypt: wrong format";
        }
        catch
        {
            return "Cannot decrypt: unknown reason";
        }
    }

    protected async Task ReloadNotebook()
    {
        try
        {
            notebook = await Http.GetFromJsonAsync<Notebook>($"api/notebook/{NbId}");
        }
        catch
        {
            NbNotFound = true;
        }
    }
    protected void ChangedNumLastRecords(string numS)
    {
        if (int.TryParse(numS, out int num))
        {
            NumLastRecords = num;
            //await AppState.Store(nameof(NumLastRecords), NumLastRecords);
        }
    }
    protected async Task AddRecordByEnter(KeyboardEventArgs e)
    {
        if ((e.Code == "Enter" || e.Code == "NumpadEnter") && !(e.AltKey || e.ShiftKey || e.CtrlKey))
        {
            await AddRecord();
        }
    }
    protected async Task AddRecord()
    {
        if (string.IsNullOrWhiteSpace(NewRecordContent)) return;
        var rec = new Record();
        if (EncryptContent)
        {
            rec.Metadata.Encrypted = true;
            rec.Content = enc.EncryptAndReturnB64(EncryptionKey, NewRecordContent);
        }
        else
        {
            rec.Content = NewRecordContent;
        }
        await Http.PostAsJsonAsync($"api/notebook/{NbId}/record", rec);
        NewRecordContent = "";
        await ReloadNotebook();
        await NewRecordContentElem.FocusAsync();
    }
    protected async Task RemoveRecord(string recId)
    {
        bool confirmed = await JsRuntime.InvokeAsync<bool>("confirm", $"Delete Record?");
        if (!confirmed) return;

        await Http.DeleteAsync($"api/notebook/{NbId}/record/{recId}");
        await ReloadNotebook();
    }
    protected async Task UpdateRecord(Record rec)
    {
        var json = JsonSerializer.Serialize(rec);
        var content = new StringContent(json);
        content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/json");
        await Http.PatchAsync($"api/notebook/{NbId}/record/{rec.Id}", content);
        await ReloadNotebook();
    }


}
